================================================================================
    AVL TREE WITH SPECIAL INSERTION RULE - COMPLETE EXPLANATION
================================================================================

TABLE OF CONTENTS:
------------------
1. Problem Statement
2. Understanding the Special Rule
3. Example Walkthrough (From Image)
4. Algorithm Design
5. Implementation Strategy
6. Code Explanation
7. Test Cases
8. Key Insights

================================================================================
1. PROBLEM STATEMENT
================================================================================

Implement an AVL Tree insertion function with a SPECIAL RULE that restricts 
insertions causing multiple imbalances during the same operation.

SPECIAL RULE:
-------------
If MORE THAN ONE node becomes imbalanced (BF = +2 or -2) during a single 
insertion operation:
→ STOP the insertion immediately
→ DO NOT modify the tree
→ The tree remains in its state before the attempted insertion

Key Points:
-----------
- 0 imbalances: Insertion accepted (tree stays balanced)
- 1 imbalance: Insertion accepted (tolerable, tree becomes slightly unbalanced)
- 2+ imbalances: Insertion REJECTED (tree remains unchanged)

================================================================================
2. UNDERSTANDING THE SPECIAL RULE
================================================================================

Normal AVL Tree Behavior:
--------------------------
In a standard AVL tree, when an insertion causes imbalances, the tree performs
rotations to fix ALL imbalances and maintain the AVL property.

This Special AVL Tree:
----------------------
Instead of fixing imbalances through rotations, this tree:
1. Attempts the insertion
2. Counts how many nodes become imbalanced
3. If count > 1: REJECT insertion and restore original tree
4. If count <= 1: ACCEPT insertion (even if tree becomes unbalanced)

Why This Rule?
--------------
This is an academic exercise to understand:
- How insertions propagate imbalances up the tree
- How to implement transactional operations (try-and-rollback)
- How to count structural changes before committing them

Real-World Analogy:
-------------------
Think of it like a building inspector:
- 0 cracks: Building is perfect, move in ✓
- 1 crack: Acceptable wear, still safe to use ✓
- 2+ cracks: Too dangerous, reject the renovation plan ✗

================================================================================
3. EXAMPLE WALKTHROUGH (FROM IMAGE)
================================================================================

Starting Tree Structure:
------------------------
       20
      /  \
    10    30
           \
           40

Let's analyze each node's balance factor:
- Node 10: BF = 0 (no children, balanced)
- Node 40: BF = 0 (no children, balanced)
- Node 30: BF = -1 (right-heavy by 1, still balanced)
- Node 20: BF = -1 (right-heavy by 1, still balanced)

All nodes are currently BALANCED (|BF| <= 1) ✓

Now, Attempt to Insert 50:
---------------------------

STEP 1: Insert 50 using standard BST insertion
Traverse: 20 → 30 → 40 → insert 50 as right child of 40

Tree becomes:
       20
      /  \
    10    30
           \
           40
            \
            50

STEP 2: Update heights and calculate balance factors (bottom-up)

At Node 50 (newly inserted):
- Height = 0 (leaf node)
- BF = 0 (no children)
- Status: Balanced ✓

At Node 40 (parent of 50):
- Left height = -1 (no left child)
- Right height = 0 (node 50)
- Height = 1
- BF = -1 - 0 = -1
- Status: Balanced ✓

At Node 30 (grandparent of 50):
- Left height = -1 (no left child)
- Right height = 1 (node 40's subtree)
- Height = 2
- BF = -1 - 2 = -2
- Status: IMBALANCED! (BF = -2) ✗
- Imbalance Count: 1

At Node 10:
- Height = 0
- BF = 0
- Status: Balanced ✓

At Node 20 (root):
- Left height = 0 (node 10)
- Right height = 3 (node 30's subtree)
- Height = 3
- BF = 0 - 3 = -2
- Status: IMBALANCED! (BF = -2) ✗
- Imbalance Count: 2

STEP 3: Check Special Rule
Imbalance Count = 2 (nodes 30 and 20 both have BF = -2)

Since imbalance count > 1:
→ REJECT THE INSERTION
→ Restore tree to its original state (before inserting 50)

Result:
-------
Tree remains:
       20
      /  \
    10    30
           \
           40

Insertion of 50 is REJECTED ✗

================================================================================
4. ALGORITHM DESIGN
================================================================================

The Challenge:
--------------
We need to:
1. Try an insertion
2. Count resulting imbalances
3. If too many, UNDO the insertion

Problem: How do we undo an insertion in a tree structure?

Solution Approach:
------------------
Use a "Try-and-Rollback" strategy:

1. BACKUP: Create a copy of the entire tree before insertion
2. TRY: Perform the insertion on the original tree
3. COUNT: Count how many nodes became imbalanced
4. DECIDE:
   - If count <= 1: Keep the modified tree, delete backup
   - If count > 1: Restore from backup, delete modified tree

This is similar to database transactions:
- BEGIN TRANSACTION (backup)
- TRY operation (insert)
- If success: COMMIT (delete backup)
- If failure: ROLLBACK (restore backup)

Alternative Approaches (Not Used):
----------------------------------
1. Simulate insertion without actually modifying tree
   - Complex: Need to track all height changes without changing tree
   
2. Use parent pointers to reverse the insertion
   - Complex: Need to track all modified nodes and reverse changes

3. Store modification log and replay in reverse
   - Complex: Need to log every change made

Our backup/restore approach is simpler and clearer.

================================================================================
5. IMPLEMENTATION STRATEGY
================================================================================

Key Functions:
--------------

1. copyTree(node)
   - Creates a deep copy of the entire tree
   - Recursively copies all nodes and maintains structure
   - Used for backup before attempting insertion

2. deleteTree(node)
   - Deletes all nodes in a tree (free memory)
   - Used to clean up backup or rejected tree

3. insertBST(node, value)
   - Performs standard BST insertion (NO rotations)
   - Updates heights of all ancestors
   - Counts nodes that become imbalanced (BF = ±2)
   - Returns root of modified tree

4. insert(value) - PUBLIC INTERFACE
   - Creates backup of current tree
   - Resets imbalance counter
   - Calls insertBST to attempt insertion
   - Checks imbalance count
   - Restores backup if count > 1
   - Deletes backup if count <= 1

Data Structure:
---------------
AVLNode:
- int data: value stored in node
- int height: height of node (for BF calculation)
- AVLNode* left: pointer to left child
- AVLNode* right: pointer to right child

AVLTree Class:
- AVLNode* root: root of the tree
- int imbalanceCount: tracks imbalances during current insertion

Flow Diagram:
-------------
insert(value)
    |
    ├─> Create backup = copyTree(root)
    |
    ├─> Reset imbalanceCount = 0
    |
    ├─> Call insertBST(root, value)
    |       |
    |       ├─> Perform BST insertion
    |       ├─> Update heights (bottom-up)
    |       ├─> Count imbalances
    |       └─> Return new root
    |
    ├─> Check imbalanceCount
    |
    ├─> If imbalanceCount > 1:
    |       ├─> deleteTree(root)
    |       ├─> root = backup
    |       └─> return false (rejected)
    |
    └─> Else:
            ├─> deleteTree(backup)
            └─> return true (accepted)

================================================================================
6. CODE EXPLANATION
================================================================================

PART 1: Tree Copying (for Backup)
----------------------------------
AVLNode* copyTree(AVLNode* node) {
    if (node == NULL) return NULL;
    
    // Create new node with same data and height
    AVLNode* newNode = new AVLNode(node->data);
    newNode->height = node->height;
    
    // Recursively copy left and right subtrees
    newNode->left = copyTree(node->left);
    newNode->right = copyTree(node->right);
    
    return newNode;
}

Time Complexity: O(n) where n = number of nodes
Space Complexity: O(n) for the copied tree + O(h) for recursion stack

PART 2: BST Insertion with Imbalance Counting
----------------------------------------------
AVLNode* insertBST(AVLNode* node, int value) {
    // Base case: found insertion position
    if (node == NULL) {
        return new AVLNode(value);
    }
    
    // Recursive insertion (standard BST)
    if (value < node->data) {
        node->left = insertBST(node->left, value);
    } else if (value > node->data) {
        node->right = insertBST(node->right, value);
    } else {
        return node;  // Duplicate, don't insert
    }
    
    // CRITICAL: After insertion, update this node's height
    updateHeight(node);
    
    // Calculate balance factor
    int balance = getBalanceFactor(node);
    
    // Check if THIS node became imbalanced
    // Only BF = +2 or -2 counts as imbalanced (not ±1)
    if (balance == 2 || balance == -2) {
        imbalanceCount++;  // Increment global counter
    }
    
    return node;
}

Key Points:
- No rotations performed (unlike standard AVL)
- Counts exact imbalances (BF = ±2 only)
- Uses global counter to track across entire insertion path

PART 3: Public Insert with Special Rule
----------------------------------------
bool insert(int value) {
    // STEP 1: Backup the tree
    AVLNode* backup = copyTree(root);
    
    // STEP 2: Reset counter
    imbalanceCount = 0;
    
    // STEP 3: Try insertion
    root = insertBST(root, value);
    
    // STEP 4: Apply special rule
    if (imbalanceCount > 1) {
        // REJECT: Too many imbalances
        deleteTree(root);      // Delete modified tree
        root = backup;          // Restore backup
        return false;           // Insertion failed
    } else {
        // ACCEPT: 0 or 1 imbalance is OK
        deleteTree(backup);    // Delete backup
        return true;            // Insertion successful
    }
}

Why This Works:
- Backup ensures we can always restore original state
- Counter tracks imbalances during insertion path
- Clean separation between try (insertBST) and decide (insert)

================================================================================
7. TEST CASES
================================================================================

Test Case 1: Insertion Creating 0 Imbalances (ACCEPTED)
--------------------------------------------------------
Initial Tree: Empty
Insert: 20
Result: Accepted (no imbalances)

Tree:
    20 (BF=0)

Test Case 2: Insertion Creating 1 Imbalance (ACCEPTED)
-------------------------------------------------------
Initial Tree:
    20
   /  \
  10   30

Insert: 40
Result: Accepted (node 30 has BF=-1, node 20 has BF=-1, no imbalances)

Insert: 50
After inserting in tree:
    20          <- BF = -2 (IMBALANCED)
   /  \
  10   30       <- BF = -1 (balanced)
        \
        40      <- BF = -1 (balanced)
         \
         50     <- BF = 0 (balanced)

Wait, let me recalculate:
Node 40: left_height=-1, right_height=0, BF=-1 (balanced)
Node 30: left_height=-1, right_height=1, BF=-2 (IMBALANCED!)
Node 20: left_height=0, right_height=2, BF=-2 (IMBALANCED!)

Actually this creates 2 imbalances, so it would be rejected.

Let me try a different sequence:

Test Case 2 (Corrected): Insertion Creating 1 Imbalance (ACCEPTED)
-------------------------------------------------------------------
Initial Tree:
    20
   /  \
  10   30

Insert: 25
Tree becomes:
    20         <- BF = -1 (balanced)
   /  \
  10   30      <- BF = 1 (balanced)
       /
      25       <- BF = 0 (balanced)

Insert: 23
Tree becomes:
    20         <- BF = -1 (balanced)
   /  \
  10   30      <- BF = 2 (IMBALANCED) <- Only 1 imbalance
       /
      25       <- BF = 1 (balanced)
      /
     23        <- BF = 0 (balanced)

Result: ACCEPTED (only 1 node imbalanced)

Test Case 3: Insertion Creating 2 Imbalances (REJECTED)
--------------------------------------------------------
(This is the example from the image)

Initial Tree:
       20
      /  \
    10    30
           \
           40

Insert: 50
Would create:
       20      <- BF = -2 (IMBALANCED)
      /  \
    10    30   <- BF = -2 (IMBALANCED)
           \
           40
            \
            50

Result: REJECTED (2 nodes imbalanced)
Tree remains unchanged.

Test Case 4: Sequential Insertions
-----------------------------------
Start empty tree
Insert 20: Accepted (0 imbalances)
Insert 10: Accepted (0 imbalances)
Insert 30: Accepted (0 imbalances)
Insert 40: Accepted (0 imbalances)
Insert 50: Rejected (2 imbalances)
Insert 5: Accepted (0 imbalances)
Insert 15: Accepted (0 imbalances)
Insert 35: Accepted (0 imbalances)

================================================================================
8. KEY INSIGHTS
================================================================================

1. IMBALANCE PROPAGATION:
   When a leaf is added, imbalances propagate upward along the insertion path.
   The farther up they propagate, the more nodes become imbalanced.

2. CASCADING EFFECT:
   If one node becomes severely imbalanced (BF = ±2), its parent may also
   become imbalanced, creating a cascade. This rule prevents such cascades.

3. TREE STRUCTURE MATTERS:
   Whether an insertion causes 1 or 2+ imbalances depends on the current
   tree structure. A more balanced tree is less likely to have multiple
   imbalances from a single insertion.

4. TRANSACTION PATTERN:
   The backup/restore pattern is a common design pattern for implementing
   atomic operations: either fully succeed or leave no changes.

5. TRADE-OFFS:
   - Pro: Simple conceptual model, clear rule
   - Con: Uses extra memory (O(n) for backup)
   - Con: Some valid insertions get rejected
   - Con: Tree can become unbalanced over time (1 imbalance is allowed)

6. COMPARISON WITH STANDARD AVL:
   Standard AVL: Always balanced, uses rotations, all insertions succeed
   This AVL: Can become unbalanced, no rotations, some insertions rejected

7. PRACTICAL USE:
   This is primarily an educational tool to understand:
   - How imbalances form and propagate
   - How to implement transactional tree operations
   - The relationship between tree structure and insertion impact

8. HEIGHT CALCULATION IS CRITICAL:
   Accurate height calculation after insertion is essential for correct
   balance factor computation. Heights must be updated bottom-up.

9. THE SPECIAL RULE IS CONSERVATIVE:
   By rejecting insertions with 2+ imbalances, the tree stays "healthier"
   but at the cost of reduced functionality (can't insert some values).

10. NO ROTATIONS NEEDED:
    Since we don't fix imbalances, we don't need rotation logic. This
    simplifies the implementation compared to standard AVL trees.

================================================================================
COMPLEXITY ANALYSIS
================================================================================

Time Complexity:
----------------
Best Case: O(h) where h = height of tree
- When insertion is accepted
- Only need to insert and update heights

Worst Case: O(n) where n = number of nodes
- When insertion is rejected
- Need to copy entire tree for backup: O(n)
- Need to insert: O(h)
- Need to delete modified tree and restore: O(n)
- Total: O(n)

Space Complexity:
-----------------
O(n) - for the backup copy of the tree
Plus O(h) for the recursion stack

This is MUCH more expensive than standard AVL which only needs O(h) space.

The price we pay for the try-and-rollback mechanism!

================================================================================
COMMON MISTAKES TO AVOID
================================================================================

1. COUNTING BF = ±1 AS IMBALANCED:
   ✗ if (balance >= 1 || balance <= -1)
   ✓ if (balance == 2 || balance == -2)
   
   Remember: BF = ±1 is still BALANCED in AVL trees

2. FORGETTING TO UPDATE HEIGHTS:
   Heights must be updated bottom-up after insertion
   Otherwise balance factors will be incorrect

3. NOT RESETTING IMBALANCE COUNTER:
   Must reset to 0 at the start of each insertion
   Otherwise it accumulates across multiple insertions

4. FORGETTING TO DELETE BACKUP OR MODIFIED TREE:
   Memory leak if we don't clean up the unused tree
   Always delete either backup or modified tree

5. SHALLOW COPY INSTEAD OF DEEP COPY:
   Must recursively copy ALL nodes
   Shallow copy would share nodes between original and backup

6. NOT HANDLING DUPLICATES:
   Should check for duplicate values and return early
   Otherwise might count false imbalances

================================================================================
END OF EXPLANATION
================================================================================

This special AVL tree implementation demonstrates:
- Transactional tree operations (backup/restore)
- Imbalance detection and counting
- Rule-based insertion acceptance/rejection
- The relationship between tree structure and insertion impact

The key learning is understanding HOW insertions cause imbalances to propagate
and WHERE in the tree structure these imbalances occur.
